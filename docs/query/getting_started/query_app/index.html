<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Comunica â€“ Querying in a JavaScript app</title><link rel="icon" href="/favicon.ico"/><link rel="foaf:primaryTopic" href="/#software"/><link rel="foaf:maker" href="https://www.rubensworks.net/#me"/><meta property="og:image" content="/img/comunica_red.svg"/><meta property="og:title" content="Comunica"/><meta property="og:description" content="A Linked Data querying framework"/><meta property="og:url" content="/"/><meta property="og:locale" content="en_US"/><meta property="og:site_name" content="Comunica"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Comunica"/><meta name="twitter:description" content="A Linked Data querying framework"/><meta name="twitter:image" content="/img/comunica_red.svg"/><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/91ebbf9cffe7f6fc9c98.css" as="style"/><link rel="stylesheet" href="/_next/static/css/91ebbf9cffe7f6fc9c98.css"/><link rel="preload" href="/_next/static/yUZSP50pbJIvLmiEMKnl0/pages/%5B...slug%5D.js" as="script"/><link rel="preload" href="/_next/static/yUZSP50pbJIvLmiEMKnl0/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-b65cab0b00afd201cbda.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.4503cc20512dbab0b6d3.js" as="script"/><link rel="preload" href="/_next/static/chunks/fad7034c189aee17e66f60b7365635c2c05bdd30.2d1038e2f506ad98da05.js" as="script"/><link rel="preload" href="/_next/static/chunks/50cd0ac05a233c396037d0e2447eab76ff58e79f.b8415198aed69072f806.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-8f0d4752a74bc455bbf4.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.fe7a32ff94d8b5e6c326.js" as="script"/></head><body><nav><a href="/"><img src="/img/comunica_white.svg" class="nav-icon"/></a><ul><li><a href="http://query.linkeddatafragments.org/">Try live</a></li><li><a href="/docs/">Docs</a></li><li><a href="/contribute/">Contribute</a></li><li><a href="/about/">About</a></li><li><a href="/ask/">Ask</a></li><li><a href="/cite/">Cite</a></li><li><a href="https://github.com/comunica/comunica">GitHub</a></li></ul></nav><div class="nav-pusher"></div><div id="__next"><div class="container-page"><main><ul class="breadcrumbs"><li><a href="/docs/">Documentation</a></li><li><a href="/docs/query/">Query with Comunica</a></li><li><a href="/docs/query/getting_started/">Getting started with querying</a></li><li>Querying in a JavaScript app</li></ul><h1>Querying in a JavaScript app</h1><hr/><div class="headers-overview"><p>On this page</p><ol class="headers-overview-elements"></ol></div><p>The default Comunica query engine that exposes most standard features is Comunica SPARQL,
which uses the package name <code>@comunica/actor-init-sparql</code>.
In this guide, we will install it as a dependency in a <a href="https://nodejs.org/en/">Node.js</a> JavaScript application,
and show how it can be used to execute queries.</p><h2 id="1--installation">1. Installation</h2><p>In order to add Comunica SPARQL as a <em>dependency</em> to your <a href="https://nodejs.org/en/">Node.js</a> application,
we can execute the following command:</p><pre><code class="bash">$ npm install @comunica/actor-init-sparql</code></pre><h2 id="2--creating-a-new-query-engine">2. Creating a new query engine</h2><p>The easiest way to create an engine is as follows:</p><pre><code class="javascript">const newEngine = require(&#x27;@comunica/actor-init-sparql&#x27;).newEngine;

const myEngine = newEngine();</code></pre><p>You can reuse an engine as often as possible.
This is especially valuable if you repeatedly query over the same sources,
as <a href="/docs/query/advanced/caching/">caching</a> can be performed. </p><h2 id="3--executing-sparql-select-queries">3. Executing SPARQL SELECT queries</h2><p>Once you engine has been created, you can use it to execute any SPARQL query, such as a <code>SELECT</code> query:</p><pre><code class="javascript">const result = await myEngine.query(`
  SELECT ?s ?p ?o WHERE {
    ?s ?p &lt;http://dbpedia.org/resource/Belgium&gt;.
    ?s ?p ?o
  } LIMIT 100`, {
  sources: [&#x27;http://fragments.dbpedia.org/2015/en&#x27;],
});</code></pre><p>The first argument of <code>query()</code> is a SPARQL query string,
and the second argument is a <a href="/docs/query/advanced/context/">query context</a> containing options,
which must at least contain an array of sources to query over. </p><p>The contents of the <code>result</code> depend on the executed query.
If the query was a <code>SELECT</code> query, it will contain one or more <strong>bindings</strong> of the selected variables (<code>?s ?p ?o</code>).</p><div><div class="note">
While the <code>sources</code> is the only required option in the query context,
<a href="/docs/query/advanced/context/">additional options can be passed</a>
to tweak how the engine executed the query.
</div></div><h3 id="3-1-consuming-binding-results-as-a-stream">3.1 Consuming binding results as a stream</h3><p>The most efficient way to make use of the result,
is by adding a <strong>data-listener</strong> to the <code>bindingsStream</code>:</p><pre><code class="javascript">result.bindingsStream.on(&#x27;data&#x27;, (binding) =&gt; {
    console.log(binding.get(&#x27;?s&#x27;).value);
    console.log(binding.get(&#x27;?s&#x27;).termType);

    console.log(binding.get(&#x27;?p&#x27;).value);

    console.log(binding.get(&#x27;?o&#x27;).value);
});</code></pre><p>The data-listener will be invoked <em>for each resulting binding</em>,
as soon as the query engine has detected it.
This means that the data-listener can be invoked many times during query execution,
even if not all results are available yet.</p><p>Each <code>binding</code> is an <a href="https://immutable-js.github.io/immutable-js/">immutable</a> object
that contains mappings from variable names to RDF terms.
Variable names are always preceded by <code>?</code>,
and bound RDF terms are represented as <a href="/docs/query/advanced/rdfjs/">RDF/JS</a>.</p><p>To find out when the query execution has <strong>ended</strong>,
and all results are passed to the data-listener,
an <strong>end-listener</strong> can be attached as well.</p><pre><code class="javascript">result.bindingsStream.on(&#x27;end&#x27;, () =&gt; {
    // The data-listener will not be called anymore once we get here.
});</code></pre><p>It is also considered good practise to add an <strong>error-listener</strong>,
so you can detect any problems that have occured during query execution:</p><pre><code class="javascript">result.bindingsStream.on(&#x27;error&#x27;, (error) =&gt; {
    console.error(error);
});</code></pre><h3 id="3-2-consuming-binding-results-as-an-array">3.2 Consuming binding results as an array</h3><p>If performance is not an issue in your application,
or you just want the results in a simple array,
then you can make use of the asynchronous <code>bindings()</code> method:</p><pre><code class="javascript">const bindings = await result.bindings();

console.log(bindings[0].get(&#x27;?s&#x27;).value);
console.log(bindings[0].get(&#x27;?s&#x27;).termType);</code></pre><p>This method will return asychronously (using <code>await</code>) as soon as <em>all</em> results have been found.
If you have many results, it is recommended to consume results iteratively with <code>bindingsStream</code> instead.</p><p>Each binding in the array is again an <a href="https://immutable-js.github.io/immutable-js/">immutable</a> object
that contains mappings from variable names to RDF terms.
Variable names are always preceded by <code>?</code>,
and bound RDF terms are represented as <a href="/docs/query/advanced/rdfjs/">RDF/JS</a>.</p><h2 id="4--executing-queries-over-multiple-sources">4. Executing queries over multiple sources</h2><p>Querying over more than one source is trivial,
as any number of sources can easily be passed via an array:</p><pre><code class="javascript">const result = await myEngine.query(`
  SELECT ?s ?p ?o WHERE {
    ?s ?p &lt;http://dbpedia.org/resource/Belgium&gt;.
    ?s ?p ?o
  } LIMIT 100`, {
  sources: [
    &#x27;http://fragments.dbpedia.org/2015/en&#x27;,
    &#x27;https://www.rubensworks.net&#x27;,
    &#x27;https://ruben.verborgh.org/profile/&#x27;,
  ],
});</code></pre><h2 id="5--executing-sparql-construct-queries">5. Executing SPARQL CONSTRUCT queries</h2><p>Next to <code>SELECT</code> queries, you can also execute a <code>CONSTRUCT</code> query to generate RDF quads/triples:</p><pre><code class="javascript">const result = await myEngine.query(`
  CONSTRUCT WHERE {
    ?s ?p ?o
  } LIMIT 100`, {
  sources: [&#x27;http://fragments.dbpedia.org/2015/en&#x27;],
});</code></pre><h3 id="5-1-consuming-quad-results-as-a-stream">5.1 Consuming quad results as a stream</h3><p>The most efficient way to make use of the resulting RDF quads,
is by adding a <strong>data-listener</strong> to the <code>quadStream</code>:</p><pre><code class="javascript">result.quadStream.on(&#x27;data&#x27;, (quad) =&gt; {
    console.log(quad.subject.value);
    console.log(quad.predicate.value);
    console.log(quad.object.value);
    console.log(quad.graph.value);
});</code></pre><p>The data-listener will be invoked <em>for each constructed RDF triple/quad</em>,
as soon as the query engine has created it.
This means that the data-listener can be invoked many times during query execution,
even if not all results are available yet.</p><p>Each <code>quad</code> is an <a href="/docs/query/advanced/rdfjs/">RDF/JS</a> quad,
which contain <code>subject</code>, <code>predicate</code>, <code>object</code> and <code>graph</code> terms.</p><p>Just like <code>bindingsStream</code>, <strong>end-listener</strong> and <strong>error-listener</strong> can also be attached:</p><pre><code class="javascript">result.quadStream.on(&#x27;end&#x27;, () =&gt; {
    // The data-listener will not be called anymore once we get here.
});
result.quadStream.on(&#x27;error&#x27;, (error) =&gt; {
    console.error(error);
});</code></pre><h3 id="5-2-consuming-quad-results-as-an-array">5.2 Consuming quad results as an array</h3><p>Just like with binding results,
if performance is not an issue in your application,
or you just want the results in a simple array,
then you can make use of the asynchronous <code>quads()</code> method:</p><pre><code class="javascript">const quads = await result.quads();

console.log(quads[0].subject.value);
console.log(quads[0].predicate.value);
console.log(quads[0].object.value);
console.log(quads[0].graph.value);</code></pre><p>This method will return asychronously (using <code>await</code>) as soon as <em>all</em> results have been found.
If you have many results, it is recommended to consume results iteratively with <code>quadStream</code> instead.</p><p>Each <code>quad</code> is again an <a href="/docs/query/advanced/rdfjs/">RDF/JS</a> quad,
which contain <code>subject</code>, <code>predicate</code>, <code>object</code> and <code>graph</code> terms.</p><h2 id="6--executing-sparql-ask-queries">6. Executing SPARQL ASK queries</h2><p>One of the simplest forms SPARQL is the ASK query,
which can be executed in Comunica as follows:</p><pre><code class="javascript">const result = await myEngine.query(`
  ASK {
    ?s ?p &lt;http://dbpedia.org/resource/Belgium&gt;
  }`, {
  sources: [&#x27;http://fragments.dbpedia.org/2015/en&#x27;],
})
const hasMatches = await result.booleanResult;</code></pre><p>The <code>booleanResult</code> field asychronously returns a boolean,
which indicates if the query has at least one result. </p><h2 id="7--serializing-to-a-specific-result-format">7. Serializing to a specific result format</h2><p>If you want your application to output query results in a certain text-based format,
just like <a href="/docs/query/getting_started/query_cli/">executing Comunica on the command line</a>,
then you can make use of the <code>resultToString()</code> method.</p><p>For example, serializing to SPARQL JSON can be done as follows:</p><pre><code class="javascript">const result = await myEngine.query(`
  SELECT ?s ?p ?o WHERE {
    ?s ?p &lt;http://dbpedia.org/resource/Belgium&gt;.
    ?s ?p ?o
  } LIMIT 100`, {
  sources: [&#x27;http://fragments.dbpedia.org/2015/en&#x27;],
});
const { data } = await myEngine.resultToString(result,
  &#x27;application/sparql-results+json&#x27;);
data.pipe(process.stdout); // Print to standard output</code></pre><p>The <code>resultToString()</code> method accepts a query result and a result format media type.
The media type is optional, and will default to <code>application/json</code> for bindings, <code>application/trig</code> for quads, and <code>simple</code> for booleans.</p><div><div class="note">
<a href="/docs/query/advanced/result_formats/">All available result formats</a> can be retrieved programmatically
by invoking the asynchronous <code>getResultMediaTypes()</code> method.
</div></div></main></div></div><footer>Â©2018 â€“ 2020Â <a href="http://www.ugent.be/">Ghent University</a>Â â€“Â <a href="http://www.imec.be/">imec</a>, Belgium<br/><a href="https://github.com/comunica/website">Source of this website</a></footer><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"Querying in a JavaScript app","description":"Execute SPARQL queries from within your application using the JavaScript API."},"body":"\nThe default Comunica query engine that exposes most standard features is Comunica SPARQL,\nwhich uses the package name `@comunica/actor-init-sparql`.\nIn this guide, we will install it as a dependency in a [Node.js](https://nodejs.org/en/) JavaScript application,\nand show how it can be used to execute queries.\n\n## 1. Installation\n\nIn order to add Comunica SPARQL as a _dependency_ to your [Node.js](https://nodejs.org/en/) application,\nwe can execute the following command:\n```bash\n$ npm install @comunica/actor-init-sparql\n```\n\n## 2. Creating a new query engine\n\nThe easiest way to create an engine is as follows:\n\n```javascript\nconst newEngine = require('@comunica/actor-init-sparql').newEngine;\n\nconst myEngine = newEngine();\n```\n\nYou can reuse an engine as often as possible.\nThis is especially valuable if you repeatedly query over the same sources,\nas [caching](/docs/query/advanced/caching/) can be performed. \n\n## 3. Executing SPARQL SELECT queries\n\nOnce you engine has been created, you can use it to execute any SPARQL query, such as a `SELECT` query:\n```javascript\nconst result = await myEngine.query(`\n  SELECT ?s ?p ?o WHERE {\n    ?s ?p \u003chttp://dbpedia.org/resource/Belgium\u003e.\n    ?s ?p ?o\n  } LIMIT 100`, {\n  sources: ['http://fragments.dbpedia.org/2015/en'],\n});\n```\n\nThe first argument of `query()` is a SPARQL query string,\nand the second argument is a [query context](/docs/query/advanced/context/) containing options,\nwhich must at least contain an array of sources to query over. \n\nThe contents of the `result` depend on the executed query.\nIf the query was a `SELECT` query, it will contain one or more **bindings** of the selected variables (`?s ?p ?o`).\n\n\u003cdiv class=\"note\"\u003e\nWhile the \u003ccode\u003esources\u003c/code\u003e is the only required option in the query context,\n\u003ca href=\"/docs/query/advanced/context/\"\u003eadditional options can be passed\u003c/a\u003e\nto tweak how the engine executed the query.\n\u003c/div\u003e\n\n### 3.1 Consuming binding results as a stream\n\nThe most efficient way to make use of the result,\nis by adding a **data-listener** to the `bindingsStream`:\n```javascript\nresult.bindingsStream.on('data', (binding) =\u003e {\n    console.log(binding.get('?s').value);\n    console.log(binding.get('?s').termType);\n\n    console.log(binding.get('?p').value);\n\n    console.log(binding.get('?o').value);\n});\n```\n\nThe data-listener will be invoked _for each resulting binding_,\nas soon as the query engine has detected it.\nThis means that the data-listener can be invoked many times during query execution,\neven if not all results are available yet.\n\nEach `binding` is an [immutable](https://immutable-js.github.io/immutable-js/) object\nthat contains mappings from variable names to RDF terms.\nVariable names are always preceded by `?`,\nand bound RDF terms are represented as [RDF/JS](/docs/query/advanced/rdfjs/).\n\nTo find out when the query execution has **ended**,\nand all results are passed to the data-listener,\nan **end-listener** can be attached as well.\n```javascript\nresult.bindingsStream.on('end', () =\u003e {\n    // The data-listener will not be called anymore once we get here.\n});\n```\n\nIt is also considered good practise to add an **error-listener**,\nso you can detect any problems that have occured during query execution:\n```javascript\nresult.bindingsStream.on('error', (error) =\u003e {\n    console.error(error);\n});\n```\n\n### 3.2 Consuming binding results as an array\n\nIf performance is not an issue in your application,\nor you just want the results in a simple array,\nthen you can make use of the asynchronous `bindings()` method:\n\n```javascript\nconst bindings = await result.bindings();\n\nconsole.log(bindings[0].get('?s').value);\nconsole.log(bindings[0].get('?s').termType);\n```\n\nThis method will return asychronously (using `await`) as soon as _all_ results have been found.\nIf you have many results, it is recommended to consume results iteratively with `bindingsStream` instead.\n\nEach binding in the array is again an [immutable](https://immutable-js.github.io/immutable-js/) object\nthat contains mappings from variable names to RDF terms.\nVariable names are always preceded by `?`,\nand bound RDF terms are represented as [RDF/JS](/docs/query/advanced/rdfjs/).\n\n## 4. Executing queries over multiple sources\n\nQuerying over more than one source is trivial,\nas any number of sources can easily be passed via an array:\n```javascript\nconst result = await myEngine.query(`\n  SELECT ?s ?p ?o WHERE {\n    ?s ?p \u003chttp://dbpedia.org/resource/Belgium\u003e.\n    ?s ?p ?o\n  } LIMIT 100`, {\n  sources: [\n    'http://fragments.dbpedia.org/2015/en',\n    'https://www.rubensworks.net',\n    'https://ruben.verborgh.org/profile/',\n  ],\n});\n```\n\n## 5. Executing SPARQL CONSTRUCT queries\n\nNext to `SELECT` queries, you can also execute a `CONSTRUCT` query to generate RDF quads/triples:\n```javascript\nconst result = await myEngine.query(`\n  CONSTRUCT WHERE {\n    ?s ?p ?o\n  } LIMIT 100`, {\n  sources: ['http://fragments.dbpedia.org/2015/en'],\n});\n```\n\n### 5.1 Consuming quad results as a stream\n\nThe most efficient way to make use of the resulting RDF quads,\nis by adding a **data-listener** to the `quadStream`:\n```javascript\nresult.quadStream.on('data', (quad) =\u003e {\n    console.log(quad.subject.value);\n    console.log(quad.predicate.value);\n    console.log(quad.object.value);\n    console.log(quad.graph.value);\n});\n```\n\nThe data-listener will be invoked _for each constructed RDF triple/quad_,\nas soon as the query engine has created it.\nThis means that the data-listener can be invoked many times during query execution,\neven if not all results are available yet.\n\nEach `quad` is an [RDF/JS](/docs/query/advanced/rdfjs/) quad,\nwhich contain `subject`, `predicate`, `object` and `graph` terms.\n\nJust like `bindingsStream`, **end-listener** and **error-listener** can also be attached:\n\n```javascript\nresult.quadStream.on('end', () =\u003e {\n    // The data-listener will not be called anymore once we get here.\n});\nresult.quadStream.on('error', (error) =\u003e {\n    console.error(error);\n});\n```\n\n### 5.2 Consuming quad results as an array\n\nJust like with binding results,\nif performance is not an issue in your application,\nor you just want the results in a simple array,\nthen you can make use of the asynchronous `quads()` method:\n\n```javascript\nconst quads = await result.quads();\n\nconsole.log(quads[0].subject.value);\nconsole.log(quads[0].predicate.value);\nconsole.log(quads[0].object.value);\nconsole.log(quads[0].graph.value);\n```\n\nThis method will return asychronously (using `await`) as soon as _all_ results have been found.\nIf you have many results, it is recommended to consume results iteratively with `quadStream` instead.\n\nEach `quad` is again an [RDF/JS](/docs/query/advanced/rdfjs/) quad,\nwhich contain `subject`, `predicate`, `object` and `graph` terms.\n\n## 6. Executing SPARQL ASK queries\n\nOne of the simplest forms SPARQL is the ASK query,\nwhich can be executed in Comunica as follows:\n```javascript\nconst result = await myEngine.query(`\n  ASK {\n    ?s ?p \u003chttp://dbpedia.org/resource/Belgium\u003e\n  }`, {\n  sources: ['http://fragments.dbpedia.org/2015/en'],\n})\nconst hasMatches = await result.booleanResult;\n```\n\nThe `booleanResult` field asychronously returns a boolean,\nwhich indicates if the query has at least one result. \n\n## 7. Serializing to a specific result format\n\nIf you want your application to output query results in a certain text-based format,\njust like [executing Comunica on the command line](/docs/query/getting_started/query_cli/),\nthen you can make use of the `resultToString()` method.\n\nFor example, serializing to SPARQL JSON can be done as follows:\n```javascript\nconst result = await myEngine.query(`\n  SELECT ?s ?p ?o WHERE {\n    ?s ?p \u003chttp://dbpedia.org/resource/Belgium\u003e.\n    ?s ?p ?o\n  } LIMIT 100`, {\n  sources: ['http://fragments.dbpedia.org/2015/en'],\n});\nconst { data } = await myEngine.resultToString(result,\n  'application/sparql-results+json');\ndata.pipe(process.stdout); // Print to standard output\n```\n\nThe `resultToString()` method accepts a query result and a result format media type.\nThe media type is optional, and will default to `application/json` for bindings, `application/trig` for quads, and `simple` for booleans.\n\n\u003cdiv class=\"note\"\u003e\n\u003ca href=\"/docs/query/advanced/result_formats/\"\u003eAll available result formats\u003c/a\u003e can be retrieved programmatically\nby invoking the asynchronous \u003ccode\u003egetResultMediaTypes()\u003c/code\u003e method.\n\u003c/div\u003e\n","path":"/docs/query/getting_started/query_app","paths":["/about/","/ask/","/cite/","/contribute/","/docs/","/docs/query/","/docs/query/getting_started/","/docs/query/getting_started/query_cli/","/docs/query/getting_started/query_cli_file/","/docs/query/getting_started/query_app/","/docs/query/getting_started/query_browser_app/","/docs/query/getting_started/query_docker/","/docs/query/getting_started/setup_endpoint/","/docs/query/getting_started/setup_web_client/","/docs/query/getting_started/query_dev_version/","/docs/query/usage/","/docs/query/faq/","/docs/query/advanced/","/docs/query/advanced/caching/","/docs/query/advanced/context/","/docs/query/advanced/federation/","/docs/query/advanced/graphql_ld/","/docs/query/advanced/hdt/","/docs/query/advanced/logging/","/docs/query/advanced/memento/","/docs/query/advanced/proxying/","/docs/query/advanced/rdfjs/","/docs/query/advanced/rdfjs_querying/","/docs/query/advanced/result_formats/","/docs/query/advanced/source_types/","/docs/query/advanced/sparql_query_types/","/docs/query/advanced/specifications/","/docs/modify/","/docs/modify/getting_started/","/docs/modify/getting_started/custom_config/","/docs/modify/extensions/","/docs/modify/faq/","/docs/modify/advanced/","/docs/modify/advanced/browser_builds/"],"mattersData":{"/about/":{"title":"About"},"/ask/":{"title":"Ask"},"/cite/":{"title":"Cite"},"/contribute/":{"title":"Contribute"},"/docs/":{"title":"Documentation","index":true},"/docs/query/":{"title":"Query with Comunica","description":"Learn how to execute queries in different environments. Such as live in the browser, in JavaScript applications, or the CLI.","index":true},"/docs/query/getting_started/":{"title":"Getting started with querying","description":"Basic guides on how to easily get started with querying.","index":true},"/docs/query/getting_started/query_cli/":{"title":"Querying from the command line","description":"Execute SPARQL queries directly from the command line."},"/docs/query/getting_started/query_cli_file/":{"title":"Querying local files from the command line","description":"Execute SPARQL queries over local RDF files directly from the command line."},"/docs/query/getting_started/query_app/":{"title":"Querying in a JavaScript app","description":"Execute SPARQL queries from within your application using the JavaScript API."},"/docs/query/getting_started/query_browser_app/":{"title":"Querying in a JavaScript browser app","description":"Execute SPARQL queries from within your client-side browser application using the JavaScript API."},"/docs/query/getting_started/query_docker/":{"title":"Querying from a Docker container","description":"Execute SPARQL queries within a Docker container."},"/docs/query/getting_started/setup_endpoint/":{"title":"Setting up a SPARQL endpoint","description":"Allow querying over HTTP via the SPARQL protocol"},"/docs/query/getting_started/setup_web_client/":{"title":"Setting up a Web client","description":"Set up a user-friendly static Web page where SPARQL queries can be executed client-side"},"/docs/query/getting_started/query_dev_version/":{"title":"Query using the latest development version","description":"If you want to make use of the latest changes that are not released yet"},"/docs/query/usage/":{"title":"Usage showcase","description":"Examples of where Comunica is used."},"/docs/query/faq/":{"title":"Querying FAQ","description":"Frequently asked questions about using Comunica."},"/docs/query/advanced/":{"title":"Advanced querying","description":"Advanced guides on how to get the most out of Comunica.","index":true},"/docs/query/advanced/caching/":{"title":"Caching","description":"When remote sources are requested, caching allows them to be reused in the future."},"/docs/query/advanced/context/":{"title":"Passing a context","description":"A context can be passed to a query engine to tweak its runtime settings."},"/docs/query/advanced/federation/":{"title":"Federated Querying","description":"Query over the union of data within any number of sources"},"/docs/query/advanced/graphql_ld/":{"title":"GraphQL-LD","description":"Using the power of JSON-LD contexts, GraphQL queries can be executed by Comunica"},"/docs/query/advanced/hdt/":{"title":"HDT","description":"HDT offers highly compressed immutable RDF storage."},"/docs/query/advanced/logging/":{"title":"Logging","description":"Loggers can be set to different logging levels to inspect what Comunica is doing behind the scenes."},"/docs/query/advanced/memento/":{"title":"Memento","description":"Using the Memento protocol, time travel queries can be executed."},"/docs/query/advanced/proxying/":{"title":"HTTP Proxy","description":"All HTTP requests can optionally go through a proxy."},"/docs/query/advanced/rdfjs/":{"title":"RDF/JS","description":"To achieve maximum interoperability between different JavaScript libraries, Comunica builds on top of the RDF/JS specifications."},"/docs/query/advanced/rdfjs_querying/":{"title":"Querying over RDF/JS sources","description":"If the built-in source types are not sufficient, you can pass a custom JavaScript object implementing a specific interface."},"/docs/query/advanced/result_formats/":{"title":"Result formats","description":"Query results can be serialized in different formats."},"/docs/query/advanced/source_types/":{"title":"Source types","description":"Comunica detects and handles different types of sources."},"/docs/query/advanced/sparql_query_types/":{"title":"SPARQL query types","description":"Different SPARQL query types are possible, such as SELECT, CONSTRUCT, ASK, ..."},"/docs/query/advanced/specifications/":{"title":"Supported specifications","description":"Comunica supports several RDF-related specifications"},"/docs/modify/":{"title":"Modify Comunica","description":"Learn how to configure your own Comunica engine, or extend Comunica by implementing new components.","index":true},"/docs/modify/getting_started/":{"title":"Getting started with modification","description":"Basic guides on how to easily get started with Comunica modification.","index":true,"wip":true},"/docs/modify/getting_started/custom_config/":{"title":"Creating a custom configuration","description":"Create a custom configuration of Comunica modules with specific features.","wip":true},"/docs/modify/extensions/":{"title":"Extensions","description":"Existing extensions of Comunica.","wip":true},"/docs/modify/faq/":{"title":"Modify FAQ","description":"Frequently asked question about Comunica modification.","wip":true},"/docs/modify/advanced/":{"title":"Advanced modification","description":"Advanced guides on how to get the most out of Comunica modification.","index":true,"wip":true},"/docs/modify/advanced/browser_builds/":{"title":"Browser builds","description":"All modules in Comunica can be built for the browser","wip":true}}},"__N_SSG":true},"page":"/[...slug]","query":{"slug":["docs","query","getting_started","query_app"]},"buildId":"yUZSP50pbJIvLmiEMKnl0","runtimeConfig":{},"nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/runtime/polyfills-ac8b02fa82de57111615.js"></script><script async="" data-next-page="/[...slug]" src="/_next/static/yUZSP50pbJIvLmiEMKnl0/pages/%5B...slug%5D.js"></script><script async="" data-next-page="/_app" src="/_next/static/yUZSP50pbJIvLmiEMKnl0/pages/_app.js"></script><script src="/_next/static/runtime/webpack-b65cab0b00afd201cbda.js" async=""></script><script src="/_next/static/chunks/framework.4503cc20512dbab0b6d3.js" async=""></script><script src="/_next/static/chunks/fad7034c189aee17e66f60b7365635c2c05bdd30.2d1038e2f506ad98da05.js" async=""></script><script src="/_next/static/chunks/50cd0ac05a233c396037d0e2447eab76ff58e79f.b8415198aed69072f806.js" async=""></script><script src="/_next/static/runtime/main-8f0d4752a74bc455bbf4.js" async=""></script><script src="/_next/static/chunks/9f96d65d.fe7a32ff94d8b5e6c326.js" async=""></script><script src="/_next/static/yUZSP50pbJIvLmiEMKnl0/_buildManifest.js" async=""></script><script src="/_next/static/yUZSP50pbJIvLmiEMKnl0/_ssgManifest.js" async=""></script></body></html>